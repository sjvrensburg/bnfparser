# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Parse and validate EBNF grammar
#'
#' @description Parses an EBNF grammar string and returns a structured list representation.
#'
#' @param input A string containing the EBNF grammar.
#' @param strict_validation Logical; whether to perform strict validation of the grammar
#'        including checking for undefined symbols, left recursion, and proper operator usage. Defaults to `TRUE`.
#' @param strict_mode Logical; whether to enforce strict symbol definitions. In strict mode, all symbols must be non-terminals (`<...>`),
#'        terminals (`"..."`), or operators. Defaults to `FALSE`.
#'
#' @return A named list representing the parsed grammar.  The names of the list are the non-terminal
#'   symbols. Each element of the list is itself a list with the following components:
#'     \itemize{
#'       \item{\code{alternatives}:}{ A list of character vectors. Each character vector represents an alternative
#'           for the non-terminal symbol, consisting of a sequence of symbols.}
#'       \item{\code{line_number}:}{ The line number in the input where the rule for this non-terminal was defined.}
#'       \item{\code{references}:}{ A character vector of non-terminal symbols referenced by this rule.}
#'     }
#'
#' @details The function parses the provided EBNF grammar string using a combination of Rcpp, Boost.Spirit, and Boost.Phoenix libraries.
#'   It supports basic EBNF syntax, including non-terminals, terminals, alternatives, and comments.  The `<start>` symbol
#'   is required in all valid grammars.
#'
#'   The `strict_validation` argument controls whether the grammar is validated for correctness.  If `strict_validation`
#'   is `TRUE` (the default), the grammar is checked for undefined symbols, left recursion (both direct and indirect), and
#'   proper operator usage.  If `strict_validation` is `FALSE`, only parsing is performed.
#'
#'   The `strict_mode` argument further refines the validation process.  In strict mode, all symbols must be either non-terminals
#'   (enclosed in angle brackets, e.g., `<expression>`), terminals (enclosed in double quotes, e.g., `"2"`), or operators.
#'   This helps to catch errors where identifiers are used without proper delimiters.
#'
#' @export
#'
#' @examples
#' \dontrun{
#' grammar_string <- '
#'   <start> ::= <expression> ;
#'   <expression> ::= <term> | <expression> "+" <term> ;
#'   <term> ::= <factor> | <term> "*" <factor> ;
#'   <factor> ::= "(" <expression> ")" | "1" | "2" ;
#' '
#' parsed_grammar <- parseBNF(grammar_string)
#' print(parsed_grammar)
#' }
parseBNF <- function(input, strict_validation = TRUE, strict_mode = FALSE) {
    .Call(`_bnfparser_parseBNF`, input, strict_validation, strict_mode)
}

